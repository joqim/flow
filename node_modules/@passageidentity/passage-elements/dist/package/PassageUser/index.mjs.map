{"version":3,"sources":["../../../src/api/PassageUser/index.ts"],"sourcesContent":["import {\n  Passage,\n  PassageError,\n  PassageErrorCode,\n  PassageUserInfo,\n  User,\n  Session,\n  ReadOnlyTokenStore,\n} from '@passageidentity/passage-js'\nimport jwtDecode, { JwtPayload } from 'jwt-decode'\n\nclass ExternalTokenStore extends ReadOnlyTokenStore {\n  constructor(private externalToken: string) {\n    super()\n  }\n\n  getAuthToken(): Promise<string> {\n    return Promise.resolve(this.externalToken)\n  }\n}\n\n/**\n * The PassageUser class retrieves information about the current user of the application.\n */\nexport class PassageUser {\n  #passageUser: User\n  #passageSession: Session\n\n  /**\n   * constructor for PassageUser class.\n   * @param {string} [auth_token] optional param to supply the auth_token (JWT) of the current user.\n   * If you provide a custom onSuccess callback to the passage elements then you will need to provide this auth_token.\n   */\n  constructor(auth_token?: string) {\n    let token: string | null\n    let tokenStore = undefined\n    if (auth_token !== undefined) {\n      token = auth_token\n      tokenStore = new ExternalTokenStore(token)\n    } else {\n      token = localStorage.getItem('psg_auth_token')\n    }\n    const appID = this._getAppId(token)\n    const passage = new Passage(appID, { tokenStore })\n    this.#passageUser = passage.getCurrentUser()\n    this.#passageSession = passage.getCurrentSession()\n  }\n\n  private _getAppId(token: string | null): string {\n    const error = new PassageError('No Passsage authToken found', {\n      status: PassageErrorCode.PSGLoginRequired,\n      statusText: 'Login required',\n    })\n    if (token === null) {\n      throw error\n    }\n    const payload = jwtDecode<JwtPayload>(token)\n    if (\n      payload !== undefined &&\n      payload.aud !== undefined &&\n      Array.isArray(payload.aud) &&\n      payload.aud[1] !== undefined\n    ) {\n      return payload.aud[1]\n    } else {\n      if (payload !== undefined && payload.iss !== undefined) {\n        const splitURL = payload.iss.split('/')\n        return splitURL[splitURL.length - 1]\n      }\n    }\n    throw error\n  }\n\n  /**\n   * authGuard checks if the current user has a JWT that is valid and potentially verifiable.\n   * IMPORTANT: this is not verifying the JWT, it is only checking if the JWT is formatted properly.\n   * @return {boolean} true if the user has a valid (but unverified) JWT, false if not.\n   */\n  public authGuard(): Promise<boolean> {\n    return this.#passageSession.authGuard()\n  }\n\n  /**\n   * userInfo returns the user information for the currently authenticated user.\n   * @return {PassageCurrentUser | undefined} the current Passage user's info, or undefined if the\n   * current Passage user's authentication token could not be verified.\n   */\n  public async userInfo(): Promise<PassageUserInfo | undefined> {\n    return this.#passageUser.userInfo()\n  }\n\n  /**\n   * Sign out a user by deleting their AuthToken from local storage and revoking their refresh token.\n   * @return {boolean} true if the device has been deleted successfully.\n   */\n  public async signOut(): Promise<boolean> {\n    return this.#passageSession.signOut()\n  }\n\n  /**\n   * getAuthToken gets the current authToken for the currently authenticated user.\n   * @return {string} returns the user's authToken if it exists or fetches a new one with a refresh token if it exists\n   */\n  public async getAuthToken(): Promise<string> {\n    return this.#passageSession.getAuthToken()\n  }\n\n  /**\n   * refresh gets and saves a new authToken for the currently authenticated user using their refresh token\n   * @return {string} returns the user's authToken if successful\n   */\n  public async refresh(): Promise<string> {\n    return (await this.#passageSession.refresh()).auth_token\n  }\n}\n\nexport type { PassageUserInfo }\n"],"mappings":"mVAAA,OACE,WAAAA,EACA,gBAAAC,EACA,oBAAAC,EAIA,sBAAAC,MACK,8BACP,OAAOC,MAA+B,aAEtC,IAAMC,EAAN,cAAiCC,CAAmB,CAClD,YAAoBC,EAAuB,CACzC,MAAM,EADY,mBAAAA,CAEpB,CAEA,cAAgC,CAC9B,OAAO,QAAQ,QAAQ,KAAK,aAAa,CAC3C,CACF,EAnBAC,EAAAC,EAwBaC,EAAN,KAAkB,CASvB,YAAYC,EAAqB,CARjCC,EAAA,KAAAJ,EAAA,QACAI,EAAA,KAAAH,EAAA,QAQE,IAAII,EACAC,EACAH,IAAe,QACjBE,EAAQF,EACRG,EAAa,IAAIT,EAAmBQ,CAAK,GAEzCA,EAAQ,aAAa,QAAQ,gBAAgB,EAE/C,IAAME,EAAQ,KAAK,UAAUF,CAAK,EAC5BG,EAAU,IAAIC,EAAQF,EAAO,CAAE,WAAAD,CAAW,CAAC,EACjDI,EAAA,KAAKV,EAAeQ,EAAQ,eAAe,GAC3CE,EAAA,KAAKT,EAAkBO,EAAQ,kBAAkB,EACnD,CAEQ,UAAUH,EAA8B,CAC9C,IAAMM,EAAQ,IAAIC,EAAa,8BAA+B,CAC5D,OAAQC,EAAiB,iBACzB,WAAY,gBACd,CAAC,EACD,GAAIR,IAAU,KACZ,MAAMM,EAER,IAAMG,EAAUC,EAAsBV,CAAK,EAC3C,GACES,IAAY,QACZA,EAAQ,MAAQ,QAChB,MAAM,QAAQA,EAAQ,GAAG,GACzBA,EAAQ,IAAI,KAAO,OAEnB,OAAOA,EAAQ,IAAI,GAEnB,GAAIA,IAAY,QAAaA,EAAQ,MAAQ,OAAW,CACtD,IAAME,EAAWF,EAAQ,IAAI,MAAM,GAAG,EACtC,OAAOE,EAASA,EAAS,OAAS,EACpC,CAEF,MAAML,CACR,CAOO,WAA8B,CACnC,OAAOM,EAAA,KAAKhB,GAAgB,UAAU,CACxC,CAOA,MAAa,UAAiD,CAC5D,OAAOgB,EAAA,KAAKjB,GAAa,SAAS,CACpC,CAMA,MAAa,SAA4B,CACvC,OAAOiB,EAAA,KAAKhB,GAAgB,QAAQ,CACtC,CAMA,MAAa,cAAgC,CAC3C,OAAOgB,EAAA,KAAKhB,GAAgB,aAAa,CAC3C,CAMA,MAAa,SAA2B,CACtC,OAAQ,MAAMgB,EAAA,KAAKhB,GAAgB,QAAQ,GAAG,UAChD,CACF,EAzFED,EAAA,YACAC,EAAA","names":["Passage","PassageError","PassageErrorCode","ReadOnlyTokenStore","jwtDecode","ExternalTokenStore","ReadOnlyTokenStore","externalToken","_passageUser","_passageSession","PassageUser","auth_token","__privateAdd","token","tokenStore","appID","passage","Passage","__privateSet","error","PassageError","PassageErrorCode","payload","jwtDecode","splitURL","__privateGet"]}