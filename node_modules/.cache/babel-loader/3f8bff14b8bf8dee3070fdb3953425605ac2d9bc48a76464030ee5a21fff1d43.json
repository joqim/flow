{"ast":null,"code":"var p = (r, e, s) => {\n  if (!e.has(r)) throw TypeError(\"Cannot \" + s);\n};\nvar i = (r, e, s) => (p(r, e, \"read from private field\"), s ? s.call(r) : e.get(r)),\n  u = (r, e, s) => {\n    if (e.has(r)) throw TypeError(\"Cannot add the same private member more than once\");\n    e instanceof WeakSet ? e.add(r) : e.set(r, s);\n  },\n  d = (r, e, s, t) => (p(r, e, \"write to private field\"), t ? t.call(r, s) : e.set(r, s), s);\nimport { Passage as f, PassageError as h, PassageErrorCode as P, ReadOnlyTokenStore as m } from \"@passageidentity/passage-js\";\nimport y from \"jwt-decode\";\nvar g = class extends m {\n    constructor(s) {\n      super();\n      this.externalToken = s;\n    }\n    getAuthToken() {\n      return Promise.resolve(this.externalToken);\n    }\n  },\n  o,\n  n,\n  c = class {\n    constructor(e) {\n      u(this, o, void 0);\n      u(this, n, void 0);\n      let s, t;\n      e !== void 0 ? (s = e, t = new g(s)) : s = localStorage.getItem(\"psg_auth_token\");\n      let a = this._getAppId(s),\n        l = new f(a, {\n          tokenStore: t\n        });\n      d(this, o, l.getCurrentUser()), d(this, n, l.getCurrentSession());\n    }\n    _getAppId(e) {\n      let s = new h(\"No Passsage authToken found\", {\n        status: P.PSGLoginRequired,\n        statusText: \"Login required\"\n      });\n      if (e === null) throw s;\n      let t = y(e);\n      if (t !== void 0 && t.aud !== void 0 && Array.isArray(t.aud) && t.aud[1] !== void 0) return t.aud[1];\n      if (t !== void 0 && t.iss !== void 0) {\n        let a = t.iss.split(\"/\");\n        return a[a.length - 1];\n      }\n      throw s;\n    }\n    authGuard() {\n      return i(this, n).authGuard();\n    }\n    async userInfo() {\n      return i(this, o).userInfo();\n    }\n    async signOut() {\n      return i(this, n).signOut();\n    }\n    async getAuthToken() {\n      return i(this, n).getAuthToken();\n    }\n    async refresh() {\n      return (await i(this, n).refresh()).auth_token;\n    }\n  };\no = new WeakMap(), n = new WeakMap();\nexport { c as PassageUser };","map":{"version":3,"names":["Passage","f","PassageError","h","PassageErrorCode","P","ReadOnlyTokenStore","m","y","g","constructor","s","externalToken","getAuthToken","Promise","resolve","o","n","c","e","u","t","localStorage","getItem","a","_getAppId","l","tokenStore","d","getCurrentUser","getCurrentSession","status","PSGLoginRequired","statusText","aud","Array","isArray","iss","split","length","authGuard","i","userInfo","signOut","refresh","auth_token","WeakMap","PassageUser"],"sources":["/Users/kaalabhairava/Documents/PassageExpress/example-react/03-Login-With-Profile/node_modules/@passageidentity/passage-elements/src/api/PassageUser/index.ts"],"sourcesContent":["import {\n  Passage,\n  PassageError,\n  PassageErrorCode,\n  PassageUserInfo,\n  User,\n  Session,\n  ReadOnlyTokenStore,\n} from '@passageidentity/passage-js'\nimport jwtDecode, { JwtPayload } from 'jwt-decode'\n\nclass ExternalTokenStore extends ReadOnlyTokenStore {\n  constructor(private externalToken: string) {\n    super()\n  }\n\n  getAuthToken(): Promise<string> {\n    return Promise.resolve(this.externalToken)\n  }\n}\n\n/**\n * The PassageUser class retrieves information about the current user of the application.\n */\nexport class PassageUser {\n  #passageUser: User\n  #passageSession: Session\n\n  /**\n   * constructor for PassageUser class.\n   * @param {string} [auth_token] optional param to supply the auth_token (JWT) of the current user.\n   * If you provide a custom onSuccess callback to the passage elements then you will need to provide this auth_token.\n   */\n  constructor(auth_token?: string) {\n    let token: string | null\n    let tokenStore = undefined\n    if (auth_token !== undefined) {\n      token = auth_token\n      tokenStore = new ExternalTokenStore(token)\n    } else {\n      token = localStorage.getItem('psg_auth_token')\n    }\n    const appID = this._getAppId(token)\n    const passage = new Passage(appID, { tokenStore })\n    this.#passageUser = passage.getCurrentUser()\n    this.#passageSession = passage.getCurrentSession()\n  }\n\n  private _getAppId(token: string | null): string {\n    const error = new PassageError('No Passsage authToken found', {\n      status: PassageErrorCode.PSGLoginRequired,\n      statusText: 'Login required',\n    })\n    if (token === null) {\n      throw error\n    }\n    const payload = jwtDecode<JwtPayload>(token)\n    if (\n      payload !== undefined &&\n      payload.aud !== undefined &&\n      Array.isArray(payload.aud) &&\n      payload.aud[1] !== undefined\n    ) {\n      return payload.aud[1]\n    } else {\n      if (payload !== undefined && payload.iss !== undefined) {\n        const splitURL = payload.iss.split('/')\n        return splitURL[splitURL.length - 1]\n      }\n    }\n    throw error\n  }\n\n  /**\n   * authGuard checks if the current user has a JWT that is valid and potentially verifiable.\n   * IMPORTANT: this is not verifying the JWT, it is only checking if the JWT is formatted properly.\n   * @return {boolean} true if the user has a valid (but unverified) JWT, false if not.\n   */\n  public authGuard(): Promise<boolean> {\n    return this.#passageSession.authGuard()\n  }\n\n  /**\n   * userInfo returns the user information for the currently authenticated user.\n   * @return {PassageCurrentUser | undefined} the current Passage user's info, or undefined if the\n   * current Passage user's authentication token could not be verified.\n   */\n  public async userInfo(): Promise<PassageUserInfo | undefined> {\n    return this.#passageUser.userInfo()\n  }\n\n  /**\n   * Sign out a user by deleting their AuthToken from local storage and revoking their refresh token.\n   * @return {boolean} true if the device has been deleted successfully.\n   */\n  public async signOut(): Promise<boolean> {\n    return this.#passageSession.signOut()\n  }\n\n  /**\n   * getAuthToken gets the current authToken for the currently authenticated user.\n   * @return {string} returns the user's authToken if it exists or fetches a new one with a refresh token if it exists\n   */\n  public async getAuthToken(): Promise<string> {\n    return this.#passageSession.getAuthToken()\n  }\n\n  /**\n   * refresh gets and saves a new authToken for the currently authenticated user using their refresh token\n   * @return {string} returns the user's authToken if successful\n   */\n  public async refresh(): Promise<string> {\n    return (await this.#passageSession.refresh()).auth_token\n  }\n}\n\nexport type { PassageUserInfo }\n"],"mappings":";;;;;;;;;AAAA,SACEA,OAAA,IAAAC,CAAA,EACAC,YAAA,IAAAC,CAAA,EACAC,gBAAA,IAAAC,CAAA,EAIAC,kBAAA,IAAAC,CAAA,QACK;AACP,OAAOC,CAAA,MAA+B;AAEtC,IAAMC,CAAA,GAAN,cAAiCF,CAAmB;IAClDG,YAAoBC,CAAA,EAAuB;MACzC,OAAM;MADY,KAAAC,aAAA,GAAAD,CAEpB;IAAA;IAEAE,aAAA,EAAgC;MAC9B,OAAOC,OAAA,CAAQC,OAAA,CAAQ,KAAKH,aAAa,CAC3C;IAAA;EACF;EAnBAI,CAAA;EAAAC,CAAA;EAwBaC,CAAA,GAAN,MAAkB;IASvBR,YAAYS,CAAA,EAAqB;MARjCC,CAAA,OAAAJ,CAAA;MACAI,CAAA,OAAAH,CAAA;MAQE,IAAIN,CAAA,EACAU,CAAA;MACAF,CAAA,KAAe,UACjBR,CAAA,GAAQQ,CAAA,EACRE,CAAA,GAAa,IAAIZ,CAAA,CAAmBE,CAAK,KAEzCA,CAAA,GAAQW,YAAA,CAAaC,OAAA,CAAQ,gBAAgB;MAE/C,IAAMC,CAAA,GAAQ,KAAKC,SAAA,CAAUd,CAAK;QAC5Be,CAAA,GAAU,IAAIzB,CAAA,CAAQuB,CAAA,EAAO;UAAEG,UAAA,EAAAN;QAAW,CAAC;MACjDO,CAAA,OAAKZ,CAAA,EAAeU,CAAA,CAAQG,cAAA,EAAe,GAC3CD,CAAA,OAAKX,CAAA,EAAkBS,CAAA,CAAQI,iBAAA,EAAkB,CACnD;IAAA;IAEQL,UAAUN,CAAA,EAA8B;MAC9C,IAAMR,CAAA,GAAQ,IAAIR,CAAA,CAAa,+BAA+B;QAC5D4B,MAAA,EAAQ1B,CAAA,CAAiB2B,gBAAA;QACzBC,UAAA,EAAY;MACd,CAAC;MACD,IAAId,CAAA,KAAU,MACZ,MAAMR,CAAA;MAER,IAAMU,CAAA,GAAUb,CAAA,CAAsBW,CAAK;MAC3C,IACEE,CAAA,KAAY,UACZA,CAAA,CAAQa,GAAA,KAAQ,UAChBC,KAAA,CAAMC,OAAA,CAAQf,CAAA,CAAQa,GAAG,KACzBb,CAAA,CAAQa,GAAA,CAAI,OAAO,QAEnB,OAAOb,CAAA,CAAQa,GAAA,CAAI;MAEnB,IAAIb,CAAA,KAAY,UAAaA,CAAA,CAAQgB,GAAA,KAAQ,QAAW;QACtD,IAAMb,CAAA,GAAWH,CAAA,CAAQgB,GAAA,CAAIC,KAAA,CAAM,GAAG;QACtC,OAAOd,CAAA,CAASA,CAAA,CAASe,MAAA,GAAS,EACpC;MAAA;MAEF,MAAM5B,CACR;IAAA;IAOO6B,UAAA,EAA8B;MACnC,OAAOC,CAAA,OAAKxB,CAAA,EAAgBuB,SAAA,EAC9B;IAAA;IAOA,MAAaE,SAAA,EAAiD;MAC5D,OAAOD,CAAA,OAAKzB,CAAA,EAAa0B,QAAA,EAC3B;IAAA;IAMA,MAAaC,QAAA,EAA4B;MACvC,OAAOF,CAAA,OAAKxB,CAAA,EAAgB0B,OAAA,EAC9B;IAAA;IAMA,MAAa9B,aAAA,EAAgC;MAC3C,OAAO4B,CAAA,OAAKxB,CAAA,EAAgBJ,YAAA,EAC9B;IAAA;IAMA,MAAa+B,QAAA,EAA2B;MACtC,QAAQ,MAAMH,CAAA,OAAKxB,CAAA,EAAgB2B,OAAA,EAAQ,EAAGC,UAChD;IAAA;EACF;AAzFE7B,CAAA,OAAA8B,OAAA,IACA7B,CAAA,OAAA6B,OAAA;AAAA,SAAA5B,CAAA,IAAA6B,WAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}